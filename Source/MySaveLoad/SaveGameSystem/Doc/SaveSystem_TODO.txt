TODO Today:
1. Rename IMySaveLoad: to include SaveLoad_ prefix
2. IMySaveableHandle: GetSaveData/AssignSaveData:
2.1. Sender: must be public available type, not UMySaverLoaderBase, which is quick saveload subsystem implemetation specific.
3. IsSaveLoad() - should it be checked when registering saveload objects in the system?

0. Saveable utils:
0.1 LogSaveable
1. Saveable object accounting in the subsystem;
1.1. Registration function in the saveable object helper
1.1.1. SaveLoad_ToString
1.1.1.1. Refactor code fragment to use SaveLoad_ToString
1.2. 

2. saveable handle object
2.0.0. USaveableHandleObject inherit IMySaveableHandle
2.0.1. Expose USaveableHandleObject operations through IMySaveableHandle
2.0.1.1. Should AssignData operations to be accessible thourgh IMySaveable, shouldn't be part of IMySaveableHandle?
2.0.1.2. Should IMySaveableHandle provide access to Register function (it's to be registered automatically)
2.0.1.3. 
2.0.2. Separate IMySaveableHandle util functions (like serialization helpers) into a separate class
2.0.3. 
2.0. Think of making it accessible to blueprint (as IMySaveable is available to BP)
2.1. Make it createable by save system;
2.2. Make Notify-of-BeginPlay-like function:
2.2.1. Check that world is game world (PIE, game) 


-----------
TODO
1. Global library (service) for working with SaveSystem entirely

*** Service locator:
1. Which system interface to be available (internal or public)?
2. Should we provide access to loader/saver?

*** Saveable object helper
1. How to access SaveSystem
2. Flags: some flags to be available within blueprint as per-object property (is SaveLoad at all).

*** Save format:
1. Identification by name: GetName() is not unique!
GetPathName()?
2. ISaveable: Unique name
2.1. Provide helper accessor
2.2. Provide default implementation
2.3. Check that all names are UNIQUE!
2.4. Use it instead of FName:
2.4.1. Loader

*** Save Load 
1. Fail of load/save should not be fatal error!!!

*** Save format
1. What about saving Outer?

*** 
1. Provide Reserve/Resize calls

*** Subsystem:
1. Is it good name "DestructedObjects" if we store only DYNAMIC destructed objects here?

*** Info serialization
FName storage?

***************************** Info
*** Info world
1. Map name

*** Info object
1. Event when object destructed (so we can automatically subscribe to it inside the system code)
2. Is object was presented at the start of the level or was created dynamically?
3. Is object was named manually or object name was generated automatically?

4. Find object by name (in the world)

*** Info destructing object
1. Is is safe to call BeginDestroy, if NO GAMEPLAY code references are to the object?
2. What about Obj->MarkPendingKill?
3. RF_PendingKill?

*** Info class
1. Class serialization